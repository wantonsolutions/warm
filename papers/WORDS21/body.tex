\section{Future Work}

\textbf{Design bottlenecks}: 
%%
C\&s operations bottleneck quickly when locking is applies across
QP~\cite{design-guidelines}, limiting the maximum performance of
systems which rely on it as a guard.  We submit two potential
approaches for reducing NIC lock contention.  \textbf{1)}remap keys to
QPs in flight. Cross QP locking can be avoided if all requests to a
shared memory address arrive on the same destination QP. \textbf{2)}
c\&s is not required for requests handled by our algorithm as they are
serialized. C\&s can be converted to writes by replacing a few RDMA
header fields. This approach would allow full operation throughput with
zero locking.

\textbf{More data structures}:
%%
Our approach is not limited to a single
data structure with associative operations. More complex structures
can be supported, however the choice of structure must be made with
care.  For our caching algorithm to resolve metadata conflicts in
network, it requires enough information to enforce remote data
structure integrity invariants. Invariants such as ordering, or
maintaining a balance in a tree require more metadata an computation to
enforce than appending to the tail of a list. We plan to investigate
data structures which have the ideal property of requiring a small
amount of metadata (ideally O(log n), or O(log log n) to maintain
their structural invariants while also supporting more operations, such
as range queries.

\textbf{Resolution Interface}:
%%
Designing and running custom code on
programmable switches is hard, while understanding how to resolve
write conflicts is relatively easy. We would like to design a generic
interface for developers to resolve write conflicts, and orchestrate
in flight RDMA.
